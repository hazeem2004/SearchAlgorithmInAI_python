# SearchAlgorithmInAI_python
1. Uniform Cost Search (UCS) with a Graph Task: Implement Uniform Cost Search (UCS) to find the least-cost path from a given start state to the goal state. Represent the graph with nodes and edges where each edge has a specific cost. You can assume that all edges will have non-negative costs. Use a priority queue to implement UCS. Return the path and its cost from start to goal. If there is no path from start to goal, print an appropriate message.
2.  2. A* Search with Custom Heuristic Task: Write an implementation of the A* Search algorithm that finds the path from a given start state to the goal state using both the path cost and a heuristic. The graph should be represented as an adjacency list with each edge having a cost. You will also be given a heuristic dictionary that provides an estimated cost from each node to the goal. Use a priority queue to implement A*. The total cost for each node is the sum of the path cost (g(n)) and the heuristic (h(n)). Return the path and its cost from start to goal. Handle situations where there is no valid path.
3.  3. Compare the Performance of DFS, BFS, UCS, and A* Task: Write a Python program to compare the performance (in terms of path length and number of nodes expanded) of Depth-First Search (DFS), Breadth-First Search (BFS), Uniform Cost Search (UCS), and A* Search on the same graph. Create a sample graph (you can represent it as an adjacency list with edge costs). Implement DFS, BFS, UCS, and A* (with a simple heuristic, e.g., straight-line distance). Run each algorithm on the same start and goal states.  Output the path length and number of nodes expanded for each algorithm.
